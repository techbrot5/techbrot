<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Confirm & Accept — TechBrot Checkout</title>

  <style>
    :root{--accent:#203A86;--muted:#6b7280;--bg:#f8fafc;--card:#fff}
    body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;margin:0;background:var(--bg);color:#111}
    .wrap{max-width:760px;margin:36px auto;padding:28px}
    .card{background:var(--card);border-radius:12px;padding:28px;box-shadow:0 6px 30px rgba(18,38,63,0.06)}
    h1{margin:0 0 6px;font-size:22px}
    p.lead{margin:6px 0 18px;color:var(--muted)}
    .plan{border:1px solid #eef2ff;border-radius:8px;padding:16px;margin-bottom:14px;background:linear-gradient(180deg,#fff,#fbfdff)}
    .plan .title{font-weight:600;font-size:16px}
    .checkbox{width:20px;height:20px;border-radius:6px;border:2px solid #cbd5e1;display:inline-flex;align-items:center;justify-content:center;cursor:pointer;flex-shrink:0}
    .checkbox.checked{background:var(--accent);border-color:var(--accent)}
    /* Let the parent handle pointer events; SVG should not block clicks */
    .checkbox svg{display:block;pointer-events:none}
    label{display:flex;gap:12px;align-items:flex-start}
    .tos{font-size:14px;color:#111}
    .tos a{color:var(--accent);text-decoration:underline}
    button.primary{background:var(--accent);color:#fff;border:none;padding:12px 18px;border-radius:8px;font-weight:600;cursor:pointer;display:inline-flex;gap:8px;align-items:center}
    button.primary[disabled]{opacity:.6;cursor:not-allowed}
    .meta{margin-top:14px;font-size:13px;color:#374151}
    .tools{display:flex;gap:8px;margin-top:14px;flex-wrap:wrap}
    .tools button{padding:8px 10px;border-radius:6px;border:1px solid #e6edf6;background:#fff;cursor:pointer}
    .note{margin-top:12px;color:#b91c1c;font-size:13px}
    .spinner{width:16px;height:16px;border-radius:50%;border:2px solid rgba(255,255,255,0.4);border-top-color:rgba(255,255,255,0.9);animation:spin .8s linear infinite;display:inline-block}
    @keyframes spin{to{transform:rotate(360deg)}}
    .helper{font-size:13px;color:var(--muted);margin-top:2px}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card" id="card-root">
      <h1>Confirm & Accept — TechBrot</h1>
      <p class="lead">Please review and accept our Terms & Refund Policy before proceeding to secure payment.</p>

      <div id="products-container" aria-live="polite"></div>

      <form id="accept-form" autocomplete="off" novalidate>
        
        <div style="margin-top:18px">
          <label class="tos" for="accept-check" id="tos-label" style="cursor:pointer">
            <div id="fake-checkbox" class="checkbox" role="button" aria-pressed="false" aria-labelledby="tos-label" tabindex="0">
              <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M20.285 6.709l-11.49 11.49-5.657-5.657 1.414-1.414 4.243 4.243 10.076-10.076z" fill="#fff"/>
              </svg>
            </div>
            <input id="accept-check" type="checkbox" style="display:none" required aria-hidden="true" />
            <div>
              <div style="font-weight:600">
                I agree to the 
                <a href="/legal/terms-and-conditions.html" target="_blank" rel="noopener noreferrer">Terms & Conditions</a> and 
                <a href="/legal/refund-cancellation" target="_blank" rel="noopener noreferrer">Refund Policy</a>.
              </div>
              <div class="helper">Payments already made are final. For billing issues contact <a href="mailto:support@techbrot.com">support@techbrot.com</a> before initiating a chargeback.</div>
            </div>
          </label>
        </div>

        <div style="display:flex;gap:12px;align-items:center;margin-top:18px">
          <button id="proceed-btn" class="primary" type="button" disabled>
            <span id="proceed-text">Proceed to Secure Payment</span>
          </button>
          <div style="flex:1;color:var(--muted);font-size:13px">You will be redirected to Stripe.</div>
        </div>

        <div class="meta" id="status" role="status" aria-live="polite"></div>

        <div class="tools">
          <button type="button" id="download-evidence" disabled>Download JSON evidence</button>
          <button type="button" id="email-evidence" disabled>Email evidence</button>
          <button type="button" id="capture-screenshot">Capture screenshot evidence</button>
        </div>

        <div class="note" id="note-text">
          We log your IP, browser, device, timestamp, acceptance state, cart contents, and page screenshot for dispute protection.
        </div>

      </form>
    </div>
  </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<script>
/* ============================
   Final patched frontend (Option A)
   base64 screenshot in JSON (Option B)
   Works with /api/acceptance-log and /api/create-checkout-session
   ============================ */

(function () {
  'use strict';

  // --- Utilities & elements ---
  const $ = (id) => document.getElementById(id);
  const statusEl = $('status');
  const proceedBtn = $('proceed-btn');
  const proceedText = $('proceed-text');
  const fakeCheckbox = $('fake-checkbox');
  const realCheckbox = $('accept-check');
  const downloadBtn = $('download-evidence');
  const emailBtn = $('email-evidence');
  const captureBtn = $('capture-screenshot');
  const productsContainer = $('products-container');
  const cardRoot = $('card-root');

  // Load and validate payload safely
  let payload = {};
  try {
    const params = new URLSearchParams(location.search);
    const raw = params.get('payload') || '{}';
    payload = JSON.parse(decodeURIComponent(raw));
  } catch (err) {
    payload = {};
    console.warn('Invalid payload in URL', err);
  }

  // Basic validation
  function isValidLineItems(items) {
    if (!Array.isArray(items) || !items.length) return false;
    return items.every(li =>
      li && (li.priceId || li.price_key || li.price || li.unit_amount || li.key)
    );
  }

  // Render products
  const products = Array.isArray(payload.cart) ? payload.cart : [];
  products.forEach((p) => {
    const div = document.createElement('div');
    div.className = 'plan';
    const productName = escapeHtml(String(p.product || 'Product'));
    const option = p.option ? ' — ' + escapeHtml(String(p.option)) : '';
    const price = typeof p.price !== 'undefined' ? escapeHtml(String(p.price)) : '—';
    const qty = typeof p.quantity !== 'undefined' ? escapeHtml(String(p.quantity)) : '1';
    const billing = p.billing ? ' • ' + escapeHtml(String(p.billing)) : '';

    div.innerHTML = `
      <div class="title">${productName}${option}</div>
      <div class="meta">
        $${price} × ${qty} ${billing}
      </div>
    `;
    productsContainer.appendChild(div);
  });

  // If no items, disable proceed and show message
  if (!isValidLineItems(payload.lineItems)) {
    statusEl.textContent = 'Invalid or missing cart data. Please return to the checkout flow.';
    proceedBtn.disabled = true;
  }

  // Accessibility + toggle logic (single source of truth)
  function setChecked(v, persist = true) {
    if (v) {
      fakeCheckbox.classList.add('checked');
      fakeCheckbox.setAttribute('aria-pressed', 'true');
      realCheckbox.checked = true;
      proceedBtn.disabled = false;
      downloadBtn.disabled = false;
      emailBtn.disabled = false;
    } else {
      fakeCheckbox.classList.remove('checked');
      fakeCheckbox.setAttribute('aria-pressed', 'false');
      realCheckbox.checked = false;
      proceedBtn.disabled = true;
      downloadBtn.disabled = true;
      emailBtn.disabled = true;
    }
    if (persist) persistChecked();
  }

  // Prevent double-toggle: we handle toggling ourselves
  fakeCheckbox.addEventListener('click', () => setChecked(!realCheckbox.checked));
  fakeCheckbox.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); setChecked(!realCheckbox.checked); } });

  // Label click toggles unless clicking a link — prevent default browser label toggle
  $('tos-label').addEventListener('click', (e) => {
    if (e.target && e.target.tagName === 'A') return; // allow links
    e.preventDefault(); // prevent native label toggle (avoid double)
    setChecked(!realCheckbox.checked);
  });

  // Persist acceptance in localStorage
  const ACCEPT_KEY = 'techbrot_accept_checked';
  try {
    const stored = localStorage.getItem(ACCEPT_KEY);
    if (stored === 'true') setChecked(true, false);
  } catch (e) {}

  function persistChecked() {
    try { localStorage.setItem(ACCEPT_KEY, realCheckbox.checked ? 'true' : 'false'); } catch (e) {}
  }
  // persist on toggle events
  fakeCheckbox.addEventListener('click', persistChecked);
  $('tos-label').addEventListener('click', persistChecked);

  // Build acceptance minimal metadata
  async function buildAcceptanceRecordBase() {
    let ip = '';
    try {
      const r = await fetch('https://api.ipify.org?format=json');
      if (r.ok) {
        const d = await r.json(); ip = d.ip || '';
      }
    } catch (e) {
      // ignore
    }

    const rawUA = navigator.userAgent || '';
    const ua = rawUA.length > 300 ? rawUA.slice(0, 300) : rawUA;

    return {
      timestamp_utc: new Date().toISOString(),
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || '',
      user_agent: ua,
      language: navigator.language || '',
      ip,
      terms_version: '1.0',
      refund_policy_version: '1.0',
      accepted: true,
      cart: Array.isArray(payload.cart) ? payload.cart : [],
      lineItems: Array.isArray(payload.lineItems) ? payload.lineItems : []
    };
  }

  // Helper: escape html
  function escapeHtml(s) {
    return s.replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  /* ===========================
     Screenshot helpers (Option A: capture cardRoot only)
     - compress, size guard, base64
     - cleanupCanvasArtifacts removes lingering canvases/iframes
     =========================== */

  function cleanupCanvasArtifacts() {
    try {
      // Remove html2canvas-created canvases (best-effort)
      document.querySelectorAll('canvas').forEach(c => {
        // Heuristic: html2canvas often sets attributes or sits off-screen; check dataset or role
        if (c.dataset && (c.dataset.html2canvas || c.classList.contains('html2canvas') || c.id?.startsWith('html2canvas'))) {
          c.remove();
        }
      });
      // also remove iframes that may be injected
      document.querySelectorAll('iframe').forEach(f => {
        if (f.className && f.className.toLowerCase().includes('html2canvas')) f.remove();
      });
      // final fallback remove fixed full-screen canvases with huge z-index
      document.querySelectorAll('canvas').forEach(c => {
        const style = window.getComputedStyle(c);
        if (style.position === 'fixed' || style.zIndex === '2147483647') {
          c.remove();
        }
      });
    } catch (e) {
      // ignore cleanup errors
      console.warn('cleanupCanvasArtifacts error', e);
    }
  }

  async function captureScreenshotBase64() {
    const target = cardRoot || document.body;
    try {
      // Capture only the card (Option A). scale 1.5 for decent resolution
      const canvas = await html2canvas(target, { scale: 1.5, useCORS: true, logging: false });
      // Convert to JPEG blob (quality 0.6)
      const blob = await new Promise((res) => canvas.toBlob(res, 'image/jpeg', 0.6));
      // Clean up any artifacts that might block pointer events
      cleanupCanvasArtifacts();
      if (!blob) throw new Error('Screenshot conversion failed');

      // Size guard: if > 2.5MB, recompress
      const maxBytes = 2.5 * 1024 * 1024;
      if (blob.size > maxBytes) {
        const reducedCanvas = document.createElement('canvas');
        const ctx = reducedCanvas.getContext('2d');
        const img = await createImageBitmap(blob);
        const scale = Math.sqrt(maxBytes / blob.size) * 0.9;
        reducedCanvas.width = Math.max(Math.round(img.width * scale), 200);
        reducedCanvas.height = Math.max(Math.round(img.height * scale), 200);
        ctx.drawImage(img, 0, 0, reducedCanvas.width, reducedCanvas.height);
        const newBlob = await new Promise((res) => reducedCanvas.toBlob(res, 'image/jpeg', 0.55));
        if (newBlob && newBlob.size < blob.size) {
          return await blobToBase64(newBlob);
        }
      }

      return await blobToBase64(blob);
    } catch (err) {
      console.warn('Screenshot failed:', err);
      cleanupCanvasArtifacts();
      return null;
    }
  }

  function blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = reject;
      reader.onloadend = () => resolve(reader.result);
      reader.readAsDataURL(blob);
    });
  }

  // Manual capture for download
  captureBtn.addEventListener('click', async () => {
    statusEl.textContent = 'Capturing screenshot…';
    captureBtn.disabled = true;
    try {
      const b64 = await captureScreenshotBase64();
      if (!b64) {
        statusEl.textContent = 'Screenshot capture failed.';
        captureBtn.disabled = false;
        return;
      }
      const blob = base64ToBlob(b64);
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `acceptance_screenshot_${new Date().toISOString().replace(/[:.]/g,'-')}.jpg`;
      a.click();
      statusEl.textContent = 'Screenshot downloaded.';
    } catch (e) {
      console.error('Manual capture error', e);
      statusEl.textContent = 'Screenshot capture failed.';
    } finally {
      captureBtn.disabled = false;
      setTimeout(() => (statusEl.textContent = ''), 2500);
    }
  });

  function base64ToBlob(dataURL) {
    const parts = dataURL.split(',');
    const byteString = atob(parts[1]);
    const mime = parts[0].match(/:(.*?);/)[1];
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    for (let i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i);
    return new Blob([ab], { type: mime });
  }

  /* ===========================
     PROCEED flow:
     - capture screenshot (card only)
     - POST to /api/acceptance-log with base64 screenshot
     - receive server order_id + evidence_hash + screenshot_url
     - POST to /api/create-checkout-session with small metadata + lineItems
     - redirect to Stripe url
     =========================== */

  proceedBtn.addEventListener('click', async () => {
    if (proceedBtn.disabled) return;
    proceedBtn.disabled = true;
    setStatus('Capturing evidence…', true);

    let screenshot_base64 = null;
    try {
      screenshot_base64 = await captureScreenshotBase64();
      if (!screenshot_base64) setStatus('Could not capture screenshot; continuing without it.', false);
    } catch (e) {
      console.warn('Screenshot exception', e);
      setStatus('Could not capture screenshot; continuing without it.', false);
    }

    // Build record and attach screenshot (or mark failure)
    const recordBase = await buildAcceptanceRecordBase();
    if (screenshot_base64) {
      recordBase.screenshot_base64 = screenshot_base64;
    } else {
      recordBase.screenshot_base64 = null;
      recordBase.screenshot_capture_failed = true;
    }

    try {
      setStatus('Saving acceptance to secure audit log…', true);
      const saveResp = await fetch('/api/acceptance-log', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        referrerPolicy: 'no-referrer',
        body: JSON.stringify(recordBase)
      });

      if (!saveResp.ok) {
        const text = await saveResp.text().catch(() => 'no body');
        console.error('acceptance-log failed:', saveResp.status, text);
        setStatus('Failed to save evidence. Try again or contact support.', false);
        proceedBtn.disabled = false;
        return;
      }

      const saveJson = await saveResp.json();
      if (!saveJson || !saveJson.order_id) {
        console.error('unexpected acceptance-log response', saveJson);
        setStatus('Failed to save evidence. Try again or contact support.', false);
        proceedBtn.disabled = false;
        return;
      }

      const serverOrderId = saveJson.order_id;
      const evidenceHash = saveJson.evidence_hash || '';
      const screenshotUrl = saveJson.screenshot_url || '';

      try { localStorage.setItem('last_order_id', serverOrderId); } catch (e) {}

      setStatus('Creating secure Stripe checkout…', true);

      const metaForStripe = {
        order_id: serverOrderId,
        evidence_hash: evidenceHash,
        screenshot_url: screenshotUrl
      };

      if (!isValidLineItems(payload.lineItems)) {
        console.error('Invalid lineItems before create-checkout-session', payload.lineItems);
        setStatus('Invalid cart. Cannot create checkout.', false);
        proceedBtn.disabled = false;
        return;
      }

      const r = await fetch('/api/create-checkout-session', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        referrerPolicy: 'no-referrer',
        body: JSON.stringify({
          metadata: metaForStripe,
          lineItems: payload.lineItems
        })
      });

      if (!r.ok) {
        const text = await r.text().catch(() => 'no body');
        console.error('create-checkout-session failed:', r.status, text);
        setStatus('Failed to create checkout session. Try again.', false);
        proceedBtn.disabled = false;
        return;
      }

      const j = await r.json();
      if (j && j.url) {
        setStatus('Redirecting to Stripe…', false);
        try { localStorage.setItem('techbrot_last_order_id', serverOrderId); } catch (e) {}
        location.href = j.url;
        return;
      }

      console.error('create-checkout-session unexpected response', j);
      setStatus('Failed to create checkout session.', false);
      proceedBtn.disabled = false;
      return;

    } catch (err) {
      console.error('Proceed flow error', err);
      setStatus('Server error. Try again or contact support.', false);
      proceedBtn.disabled = false;
    }
  });

  // small status helper
  function setStatus(msg, spinner) {
    statusEl.textContent = '';
    if (spinner) {
      const sp = document.createElement('span');
      sp.className = 'spinner';
      sp.setAttribute('aria-hidden', 'true');
      statusEl.appendChild(sp);
      statusEl.appendChild(document.createTextNode(' ' + msg));
    } else {
      statusEl.textContent = msg;
    }
  }

  // Tools: download & email evidence
  downloadBtn.addEventListener('click', async () => {
    downloadBtn.disabled = true;
    try {
      const rec = await buildAcceptanceRecordBase();
      try { rec.server_order_id = localStorage.getItem('last_order_id') || null; } catch (e) {}
      const blob = new Blob([JSON.stringify(rec, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `techbrot_evidence_${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
      a.click();
    } catch (e) {
      console.error('Download evidence failed', e);
      alert('Failed to create evidence file.');
    } finally {
      downloadBtn.disabled = false;
    }
  });

  emailBtn.addEventListener('click', async () => {
    emailBtn.disabled = true;
    try {
      const rec = await buildAcceptanceRecordBase();
      try { rec.server_order_id = localStorage.getItem('last_order_id') || null; } catch (e) {}
      const body = encodeURIComponent(JSON.stringify(rec, null, 2));
      location.href = `mailto:support@techbrot.com?subject=Evidence%20from%20checkout&body=${body}`;
    } catch (e) {
      console.error('Email evidence failed', e);
      alert('Failed to prepare email.');
    } finally {
      emailBtn.disabled = false;
    }
  });

  // Clear transient status after inactivity
  setTimeout(() => { if (!statusEl.textContent) statusEl.textContent = ''; }, 5000);

  console.info('TechBrot acceptance frontend loaded (Option A: card capture).');

})();
</script>

</body>
</html>
