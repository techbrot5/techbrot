<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Confirm & Accept — TechBrot Inc. Checkout</title>

  <style>
    :root{--accent:#203A86;--muted:#6b7280;--bg:#f8fafc;--card:#fff}
    body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;margin:0;background:var(--bg);color:#111}
    .wrap{max-width:760px;margin:36px auto;padding:28px}
    .card{background:var(--card);border-radius:12px;padding:28px;box-shadow:0 6px 30px rgba(18,38,63,0.06)}
    h1{margin:0 0 6px;font-size:22px}
    p.lead{margin:6px 0 18px;color:var(--muted)}

    /* ===== NEW: 50/50 grid for plans (responsive) ===== */
    #products-container {
      display:grid;
      grid-template-columns: repeat(2, 1fr);
      gap:14px;
      margin-bottom:8px;
    }
    @media (max-width:600px){ #products-container { grid-template-columns: 1fr; } }

    .plan{border:1px solid #eef2ff;border-radius:8px;padding:12px 14px;margin-bottom:0;background:linear-gradient(180deg,#fff,#fbfdff);min-height:64px;display:flex;flex-direction:column;justify-content:center}
    /* Truncate long product names */
    .plan .title{font-weight:600;font-size:15px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;max-width:100%}

    .checkbox{width:20px;height:20px;border-radius:6px;border:2px solid #cbd5e1;display:inline-flex;align-items:center;justify-content:center;cursor:pointer;flex-shrink:0;transition:transform .14s ease, background .18s ease, border-color .18s ease;}
    /* animated checkbox: scale + subtle pop */
    .checkbox:active{transform:scale(.96);}
    .checkbox svg{display:block;pointer-events:none;transform-origin:center;transform:scale(.6);transition:transform .18s cubic-bezier(.2,.8,.2,1)}
    .checkbox.checked{background:var(--accent);border-color:var(--accent)}
    .checkbox.checked svg{transform:scale(1);}

    label{display:flex;gap:12px;align-items:flex-start}
    .tos{font-size:14px;color:#111}
    .tos a{color:var(--accent);text-decoration:underline}
    button.primary{background:var(--accent);color:#fff;border:none;padding:12px 18px;border-radius:8px;font-weight:600;cursor:pointer;display:inline-flex;gap:8px;align-items:center}
    button.primary[disabled]{opacity:.6;cursor:not-allowed}
    .meta{margin-top:14px;font-size:13px;color:#374151}
    .tools{display:flex;gap:8px;margin-top:14px;flex-wrap:wrap}
    .tools button{padding:8px 10px;border-radius:6px;border:1px solid #e6edf6;background:#fff;cursor:pointer}
    .note{margin-top:12px;color:#b91c1c;font-size:13px}
    .spinner{width:16px;height:16px;border-radius:50%;border:2px solid rgba(255,255,255,0.4);border-top-color:rgba(255,255,255,0.9);animation:spin .8s linear infinite;display:inline-block}
    @keyframes spin{to{transform:rotate(360deg)}}
    .helper{font-size:13px;color:var(--muted);margin-top:2px}

    /* email input */
    .email-field{margin:12px 0 16px}
    .email-field input{width:100%;padding:12px;border-radius:8px;border:1px solid #d1d5db;font-size:15px;background:#fff}

    /* loading skeleton */
    .skeleton-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:14px}
    .skeleton-card{height:64px;border-radius:8px;background:linear-gradient(90deg,#f2f5fb,#eef4ff,#f2f5fb);animation:skeleton-anim 1.2s infinite linear;background-size:200% 100%}
    @keyframes skeleton-anim{0%{background-position:200% 0}100%{background-position:-200% 0}}
    @media (max-width:600px){ .skeleton-grid{grid-template-columns:1fr} }

    /* small helper for product meta inside plan */
    .plan .meta{font-size:13px;color:var(--muted);margin-top:6px}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card" id="card-root">
      <h1>Confirm & Accept — TechBrot Inc.</h1>
      <p class="lead">Please review and accept our Terms & Refund Policy before proceeding to secure payment.</p>

      <!-- SKELETON shows first while JS renders -->
      <div id="products-container" aria-live="polite">
        <div class="skeleton-grid" id="skeleton">
          <div class="skeleton-card"></div>
          <div class="skeleton-card"></div>
        </div>
      </div>

      <!-- EMAIL placed directly below plans -->
      <div class="email-field" aria-hidden="false">
        <label for="email" style="font-size:14px;font-weight:600;display:block;margin-bottom:6px;">Email Address (required)</label>
        <input id="email" name="email" type="email" required placeholder="you@example.com" autocomplete="email" />
        <div class="helper">Used to link your acceptance record to your Stripe receipt.</div>
      </div>

      <form id="accept-form" autocomplete="off" novalidate>

        <div style="margin-top:18px">
          <label class="tos" for="accept-check" id="tos-label" style="cursor:pointer">
            <div id="fake-checkbox" class="checkbox" role="button" aria-pressed="false" aria-labelledby="tos-label" tabindex="0">
              <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M20.285 6.709l-11.49 11.49-5.657-5.657 1.414-1.414 4.243 4.243 10.076-10.076z" fill="#fff"/>
              </svg>
            </div>
            <input id="accept-check" type="checkbox" style="display:none" required aria-hidden="true" />
            <div>
              <div style="font-weight:600">
                I agree to the 
                <a href="/legal/terms-and-conditions.html" target="_blank" rel="noopener noreferrer">Terms & Conditions</a> and 
                <a href="/legal/refund-cancellation" target="_blank" rel="noopener noreferrer">Refund Policy</a>.
              </div>
              <div class="helper">Payments already made are final. For billing issues contact <a href="mailto:support@techbrot.com">support@techbrot.com</a> before initiating a chargeback.</div>
            </div>
          </label>
        </div>

        <div style="display:flex;gap:12px;align-items:center;margin-top:18px">
          <button id="proceed-btn" class="primary" type="button" disabled>
            <span id="proceed-text">Proceed to Secure Payment</span>
          </button>
          <div style="flex:1;color:var(--muted);font-size:13px">You will be redirected to Stripe.</div>
        </div>

        <div class="meta" id="status" role="status" aria-live="polite"></div>

        <div class="tools">
          <button type="button" id="download-evidence" disabled>Download JSON evidence</button>
          <button type="button" id="email-evidence" disabled>Email evidence</button>
          <button type="button" id="capture-screenshot">Capture screenshot evidence</button>
        </div>

        <div class="note" id="note-text">
          We log your IP, browser, device, timestamp, acceptance state, cart contents, and page screenshot for dispute protection.
        </div>

      </form>
    </div>
  </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<script>
/* ============================
   Your original JS preserved.
   Additions: skeleton removal, email handling,
   and small animated checkbox hookup.
   All original functions remain intact and unchanged.
   ============================ */

(function () {
  'use strict';

  // --- Utilities & elements ---
  const $ = (id) => document.getElementById(id);
  const statusEl = $('status');
  const proceedBtn = $('proceed-btn');
  const proceedText = $('proceed-text');
  const fakeCheckbox = $('fake-checkbox');
  const realCheckbox = $('accept-check');
  const downloadBtn = $('download-evidence');
  const emailBtn = $('email-evidence');
  const captureBtn = $('capture-screenshot');
  const productsContainer = $('products-container');
  const cardRoot = $('card-root');
  const emailInput = $('email');
  const skeletonEl = $('skeleton');

  // Load and validate payload safely
  let payload = {};
  try {
    const params = new URLSearchParams(location.search);
    const raw = params.get('payload') || '{}';
    payload = JSON.parse(decodeURIComponent(raw));
  } catch (err) {
    payload = {};
    console.warn('Invalid payload in URL', err);
  }

  // Basic validation
  function isValidLineItems(items) {
    if (!Array.isArray(items) || !items.length) return false;
    return items.every(li =>
      li && (li.priceId || li.price_key || li.price || li.unit_amount || li.key)
    );
  }

  // Helper: escape html
  function escapeHtml(s) {
    return s.replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  // Render products (keep all original logic, just remove skeleton afterwards)
  function renderProducts() {
    // remove skeleton if exists
    if (skeletonEl) {
      try { skeletonEl.remove(); } catch (e) {}
    }

    const products = Array.isArray(payload.cart) ? payload.cart : [];
    products.forEach((p) => {
      const div = document.createElement('div');
      div.className = 'plan';
      const productName = escapeHtml(String(p.product || 'Product'));
      const option = p.option ? ' — ' + escapeHtml(String(p.option)) : '';
      const price = typeof p.price !== 'undefined' ? escapeHtml(String(p.price)) : '—';
      const qty = typeof p.quantity !== 'undefined' ? escapeHtml(String(p.quantity)) : '1';
      const billing = p.billing ? ' • ' + escapeHtml(String(p.billing)) : '';

      // truncate name for display but keep full title in tooltip
      const displayName = productName.length > 20 ? productName.slice(0, 18) + '…' : productName;

      div.innerHTML = `
        <div class="title" title="${productName}${option}">${displayName}${option}</div>
        <div class="meta">
          $${price} × ${qty} ${billing}
        </div>
      `;
      productsContainer.appendChild(div);
    });

    // If no items, disable proceed and show message
    if (!isValidLineItems(payload.lineItems)) {
      statusEl.textContent = 'Invalid or missing cart data. Please return to the checkout flow.';
      proceedBtn.disabled = true;
    }
  }

  // call render on next tick so skeleton is visible briefly
  setTimeout(renderProducts, 150);

  // Accessibility + toggle logic (single source of truth)
  // NOTE: we keep your original setChecked but require valid email to enable proceed
  function isEmailValid() {
    try {
      return emailInput && emailInput.value && emailInput.checkValidity();
    } catch (e) { return false; }
  }

  function setChecked(v, persist = true) {
    if (v) {
      fakeCheckbox.classList.add('checked');
      fakeCheckbox.setAttribute('aria-pressed', 'true');
      realCheckbox.checked = true;
      // require email valid to enable proceed (new requirement)
      if (isEmailValid()) {
        proceedBtn.disabled = false;
        downloadBtn.disabled = false;
        emailBtn.disabled = false;
      } else {
        proceedBtn.disabled = true;
        downloadBtn.disabled = true;
        emailBtn.disabled = true;
      }
    } else {
      fakeCheckbox.classList.remove('checked');
      fakeCheckbox.setAttribute('aria-pressed', 'false');
      realCheckbox.checked = false;
      proceedBtn.disabled = true;
      downloadBtn.disabled = true;
      emailBtn.disabled = true;
    }
    if (persist) persistChecked();
  }

  // Prevent double-toggle: we handle toggling ourselves
  fakeCheckbox.addEventListener('click', () => setChecked(!realCheckbox.checked));
  fakeCheckbox.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); setChecked(!realCheckbox.checked); } });

  // Label click toggles unless clicking a link — prevent default browser label toggle
  $('tos-label').addEventListener('click', (e) => {
    if (e.target && e.target.tagName === 'A') return; // allow links
    e.preventDefault(); // prevent native label toggle (avoid double)
    setChecked(!realCheckbox.checked);
  });

  // Persist acceptance in localStorage
  const ACCEPT_KEY = 'techbrot_accept_checked';
  try {
    const stored = localStorage.getItem(ACCEPT_KEY);
    if (stored === 'true') setChecked(true, false);
  } catch (e) {}

  function persistChecked() {
    try { localStorage.setItem(ACCEPT_KEY, realCheckbox.checked ? 'true' : 'false'); } catch (e) {}
  }
  // persist on toggle events
  fakeCheckbox.addEventListener('click', persistChecked);
  $('tos-label').addEventListener('click', persistChecked);

  // Build acceptance minimal metadata
  async function buildAcceptanceRecordBase() {
    let ip = '';
    try {
      const r = await fetch('https://api.ipify.org?format=json');
      if (r.ok) {
        const d = await r.json(); ip = d.ip || '';
      }
    } catch (e) {
      // ignore
    }

    const rawUA = navigator.userAgent || '';
    const ua = rawUA.length > 300 ? rawUA.slice(0, 300) : rawUA;

    return {
      timestamp_utc: new Date().toISOString(),
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || '',
      user_agent: ua,
      language: navigator.language || '',
      ip,
      terms_version: '1.0',
      refund_policy_version: '1.0',
      accepted: true,
      // Include email now so D1 receives it
      email: (function(){ try { return document.getElementById('email').value || ''; } catch(e){ return ''; } })(),
      cart: Array.isArray(payload.cart) ? payload.cart : [],
      lineItems: Array.isArray(payload.lineItems) ? payload.lineItems : []
    };
  }

  // Helper: escape html (already declared above but safe to leave)
  function escapeHtml(s) {
    return s.replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  /* ===========================
     Screenshot helpers (Option A: capture cardRoot only)
     - compress, size guard, base64
     - cleanupCanvasArtifacts removes lingering canvases/iframes
     =========================== */

  function cleanupCanvasArtifacts() {
    try {
      // Remove html2canvas-created canvases (best-effort)
      document.querySelectorAll('canvas').forEach(c => {
        // Heuristic: html2canvas often sets attributes or sits off-screen; check dataset or role
        if (c.dataset && (c.dataset.html2canvas || c.classList.contains('html2canvas') || c.id?.startsWith('html2canvas'))) {
          c.remove();
        }
      });
      // also remove iframes that may be injected
      document.querySelectorAll('iframe').forEach(f => {
        if (f.className && f.className.toLowerCase().includes('html2canvas')) f.remove();
      });
      // final fallback remove fixed full-screen canvases with huge z-index
      document.querySelectorAll('canvas').forEach(c => {
        const style = window.getComputedStyle(c);
        if (style.position === 'fixed' || style.zIndex === '2147483647') {
          c.remove();
        }
      });
    } catch (e) {
      // ignore cleanup errors
      console.warn('cleanupCanvasArtifacts error', e);
    }
  }

  async function captureScreenshotBase64() {
    const target = cardRoot || document.body;
    try {
      // Capture only the card (Option A). scale 1.5 for decent resolution
      const canvas = await html2canvas(target, { scale: 1.5, useCORS: true, logging: false });
      // Convert to JPEG blob (quality 0.6)
      const blob = await new Promise((res) => canvas.toBlob(res, 'image/jpeg', 0.6));
      // Clean up any artifacts that might block pointer events
      cleanupCanvasArtifacts();
      if (!blob) throw new Error('Screenshot conversion failed');

      // Size guard: if > 2.5MB, recompress
      const maxBytes = 2.5 * 1024 * 1024;
      if (blob.size > maxBytes) {
        const reducedCanvas = document.createElement('canvas');
        const ctx = reducedCanvas.getContext('2d');
        const img = await createImageBitmap(blob);
        const scale = Math.sqrt(maxBytes / blob.size) * 0.9;
        reducedCanvas.width = Math.max(Math.round(img.width * scale), 200);
        reducedCanvas.height = Math.max(Math.round(img.height * scale), 200);
        ctx.drawImage(img, 0, 0, reducedCanvas.width, reducedCanvas.height);
        const newBlob = await new Promise((res) => reducedCanvas.toBlob(res, 'image/jpeg', 0.55));
        if (newBlob && newBlob.size < blob.size) {
          return await blobToBase64(newBlob);
        }
      }

      return await blobToBase64(blob);
    } catch (err) {
      console.warn('Screenshot failed:', err);
      cleanupCanvasArtifacts();
      return null;
    }
  }

  function blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = reject;
      reader.onloadend = () => resolve(reader.result);
      reader.readAsDataURL(blob);
    });
  }

  // Manual capture for download
  captureBtn.addEventListener('click', async () => {
    statusEl.textContent = 'Capturing screenshot…';
    captureBtn.disabled = true;
    try {
      const b64 = await captureScreenshotBase64();
      if (!b64) {
        statusEl.textContent = 'Screenshot capture failed.';
        captureBtn.disabled = false;
        return;
      }
      const blob = base64ToBlob(b64);
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `acceptance_screenshot_${new Date().toISOString().replace(/[:.]/g,'-')}.jpg`;
      a.click();
      statusEl.textContent = 'Screenshot downloaded.';
    } catch (e) {
      console.error('Manual capture error', e);
      statusEl.textContent = 'Screenshot capture failed.';
    } finally {
      captureBtn.disabled = false;
      setTimeout(() => (statusEl.textContent = ''), 2500);
    }
  });

  function base64ToBlob(dataURL) {
    const parts = dataURL.split(',');
    const byteString = atob(parts[1]);
    const mime = parts[0].match(/:(.*?);/)[1];
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    for (let i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i);
    return new Blob([ab], { type: mime });
  }

 /* ===========================
   PROCEED flow:
   - capture screenshot (card only)
   - POST to /api/acceptance-log with base64 screenshot
   - receive server order_id + evidence_hash + screenshot_url
   - STORE post-payment evidence tracking (critical)
   - POST to /api/create-checkout-session with metadata + lineItems
   - redirect to Stripe url
   =========================== */

proceedBtn.addEventListener('click', async () => {
  if (proceedBtn.disabled) return;
  proceedBtn.disabled = true;
  setStatus('Capturing evidence…', true);

  let screenshot_base64 = null;
  try {
    screenshot_base64 = await captureScreenshotBase64();
    if (!screenshot_base64) {
      setStatus('Could not capture screenshot; continuing without it.', false);
    }
  } catch (e) {
    console.warn('Screenshot exception', e);
    setStatus('Could not capture screenshot; continuing without it.', false);
  }

  // Build record and attach screenshot
  const recordBase = await buildAcceptanceRecordBase();
  if (screenshot_base64) {
    recordBase.screenshot_base64 = screenshot_base64;
  } else {
    recordBase.screenshot_base64 = null;
    recordBase.screenshot_capture_failed = true;
  }

  // Save acceptance for fallback evidence
  try {
    localStorage.setItem('techbrot_acceptance_record', JSON.stringify(recordBase));
  } catch (e) {
    console.warn('Failed to store acceptance record', e);
  }

  try {
    setStatus('Saving acceptance to secure audit log…', true);

    const saveResp = await fetch('/api/acceptance-log', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      referrerPolicy: 'no-referrer',
      body: JSON.stringify(recordBase)
    });

    if (!saveResp.ok) {
      const text = await saveResp.text().catch(() => 'no body');
      console.error('acceptance-log failed:', saveResp.status, text);
      setStatus('Failed to save evidence. Try again or contact support.', false);
      proceedBtn.disabled = false;
      return;
    }

    const saveJson = await saveResp.json();
    if (!saveJson || !saveJson.order_id) {
      console.error('unexpected acceptance-log response', saveJson);
      setStatus('Failed to save evidence. Try again or contact support.', false);
      proceedBtn.disabled = false;
      return;
    }

    const serverOrderId = saveJson.order_id;
    const evidenceHash = saveJson.evidence_hash || '';
    const screenshotUrl = saveJson.screenshot_url || '';

    try { localStorage.setItem('last_order_id', serverOrderId); } catch (e) {}

    /* =====================================================
       ⭐ CRITICAL FIX: STORE POST-PAYMENT TRACKING VALUES
       ===================================================== */
    try {
      localStorage.setItem('techbrot_last_order_id', serverOrderId);
      localStorage.setItem('techbrot_email', emailInput.value || '');

      // Safe fallback for amount
      const planAmount =
        (payload?.cart?.[0]?.price) ||
        (payload?.lineItems?.[0]?.unit_amount) ||
        0;

      localStorage.setItem('techbrot_amount', planAmount);
    } catch (e) {
      console.warn('Failed to store post-payment evidence values', e);
    }
    /* ===================================================== */

    setStatus('Creating secure Stripe checkout…', true);

    const metaForStripe = {
      order_id: serverOrderId,
      evidence_hash: evidenceHash,
      screenshot_url: screenshotUrl
    };

    if (!isValidLineItems(payload.lineItems)) {
      console.error('Invalid lineItems before create-checkout-session', payload.lineItems);
      setStatus('Invalid cart. Cannot create checkout.', false);
      proceedBtn.disabled = false;
      return;
    }

    // ---- NORMALIZE lineItems before creating the Stripe session ----
    function parsePriceString(s) {
      if (s === null || s === undefined) return null;
      const cleaned = String(s).replace(/[^0-9.]/g, '');
      const n = Number(cleaned);
      return Number.isFinite(n) ? n : null;
    }

    // ===== NORMALIZED LINE ITEMS (REPLACEMENT START) =====
    const normalizedLineItems = (Array.isArray(payload.lineItems) ? payload.lineItems : []).map(li => {

      const needleRaw = String(
        li.key ||
        li.price_key ||
        li.priceId ||
        li.priceKey ||
        li.product ||
        li.label ||
        li.name ||
        ''
      ).trim();

      function normalizeKeyFront(k) {
        if (!k) return '';
        return String(k)
          .toLowerCase()
          .trim()
          .replace(/\$/g, '')
          .replace(/&/g, 'and')
          .replace(/[\|\/\\]+/g, ' ')
          .replace(/[^a-z0-9\s-]+/g, ' ')
          .replace(/\s+/g, ' ')
          .replace(/[-\s]+/g, '_');
      }

      const needle = normalizeKeyFront(needleRaw);

      const cartMatch = (Array.isArray(payload.cart) ? payload.cart : []).find(c => {
        const candidates = [
          c.key,
          c.product,
          c.name,
          c.label,
          c.option
        ]
          .filter(Boolean)
          .map(x => normalizeKeyFront(String(x)));

        return (
          candidates.includes(needle) ||
          candidates.some(x => needle && x.includes(needle))
        );
      });

      function parsePriceString(s) {
        if (s === null || s === undefined) return null;
        const cleaned = String(s).replace(/[^0-9.]/g, '');
        const n = Number(cleaned);
        return Number.isFinite(n) ? n : null;
      }

      let amountDollars = null;

      if (cartMatch && typeof cartMatch.price !== 'undefined') {
        amountDollars = parsePriceString(cartMatch.price);
      }

      if (amountDollars === null) {
        const fallback = li.unit_amount ?? li.price ?? li.unitAmount ?? 0;
        const parsedFallback = parsePriceString(fallback);
        amountDollars = parsedFallback !== null ? parsedFallback : Number(fallback) || 0;
      }

      if (Math.abs(amountDollars) >= 10000) amountDollars = amountDollars / 100;
      amountDollars = Number(amountDollars || 0);

      let billing = null;

      const bm =
        (cartMatch && (cartMatch.billing || cartMatch.interval || cartMatch.recurring || cartMatch.option || cartMatch.label)) ||
        li.billing ||
        li.interval ||
        li.recurring ||
        null;

      if (bm && typeof bm === 'string') {
        const b = bm.trim().toLowerCase();
        if (b.includes('ann') || b === 'year' || b === 'annual' || b.includes('yr'))
          billing = 'annual';
        else if (b.includes('month') || b === 'monthly' || b.includes('mo'))
          billing = 'monthly';
        else if (b.includes('one') || b.includes('session') || b.includes('single') || b.includes('one-time'))
          billing = 'one_time';
      }

      if (!billing && needle) {
        if (needle.includes('annual') || needle.includes('_yr') || needle.includes('year')) billing = 'annual';
        else if (needle.includes('monthly') || needle.includes('_mo') || needle.includes('month')) billing = 'monthly';
        else if (needle.includes('one') || needle.includes('session') || needle.includes('single')) billing = 'one_time';
      }

      const productNameCheck = String(cartMatch && (cartMatch.product || cartMatch.name || cartMatch.option || cartMatch.label) || '').toLowerCase();
      if (!billing &&
        (productNameCheck.includes('session') ||
         productNameCheck.includes('sessions') ||
         productNameCheck.includes('cleanup') ||
         productNameCheck.includes('catch-up') ||
         productNameCheck.includes('quickstart'))) {
        billing = 'one_time';
      }

      const explicitPriceId = (li.priceId || li.price_id || li.price_key || li.priceKey || null);
      const explicitIsStripePrice = explicitPriceId && String(explicitPriceId).startsWith('price_');

      let baseKey = needle || '';
      baseKey = baseKey.replace(/_(annual|monthly|month|yr|year|one_time|one|one-time|session|sessions|single|_mo|_yr)$/i, '').replace(/_+$/,'');
      if (!baseKey && cartMatch) {
        baseKey = normalizeKeyFront(String(cartMatch.key || cartMatch.product || cartMatch.name || cartMatch.label || ''));
      }
      baseKey = baseKey || needle || '';

      let candidatePriceKey = null;
      if (billing === 'annual' && baseKey) candidatePriceKey = `${baseKey}_annual`;
      else if (billing === 'monthly' && baseKey) candidatePriceKey = `${baseKey}_monthly`;
      else if (billing === 'one_time' && baseKey) candidatePriceKey = `${baseKey}_one_time`;
      else if (baseKey) candidatePriceKey = baseKey;

      const outgoingPriceId = explicitIsStripePrice ? explicitPriceId : null;
      const outgoingPriceKey = outgoingPriceId ? null : (candidatePriceKey || null);

      return {
        ...li,
        unit_amount: amountDollars,
        quantity: Number(li.quantity || 1),
        billing,
        priceId: outgoingPriceId,
        priceKey: outgoingPriceKey,
        key: li.key || li.price_key || li.priceKey || li.priceId || li.product || li.name || null
      };
    });

    console.log('normalizedLineItems ->', JSON.stringify(normalizedLineItems, null, 2));
    // ===== NORMALIZED LINE ITEMS (REPLACEMENT END) =====

    const r = await fetch('/api/create-checkout-session', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      referrerPolicy: 'no-referrer',
      body: JSON.stringify({
        metadata: metaForStripe,
        lineItems: normalizedLineItems,
        email: document.getElementById('email').value || ''
      })
    });

    if (!r.ok) {
      const text = await r.text().catch(() => 'no body');
      console.error('create-checkout-session failed:', r.status, text);
      setStatus('Failed to create checkout session. Try again.', false);
      proceedBtn.disabled = false;
      return;
    }

    const j = await r.json();
    if (j && j.url) {
      setStatus('Redirecting to Stripe…', false);
      try { localStorage.setItem('techbrot_last_order_id', serverOrderId); } catch (e) {}
      location.href = j.url;
      return;
    }

    console.error('create-checkout-session unexpected response', j);
    setStatus('Failed to create checkout session.', false);
    proceedBtn.disabled = false;

  } catch (err) {
    console.error('Proceed flow error', err);
    setStatus('Server error. Try again or contact support.', false);
    proceedBtn.disabled = false;
  }
});


  // small status helper
  function setStatus(msg, spinner) {
    statusEl.textContent = '';
    if (spinner) {
      const sp = document.createElement('span');
      sp.className = 'spinner';
      sp.setAttribute('aria-hidden', 'true');
      statusEl.appendChild(sp);
      statusEl.appendChild(document.createTextNode(' ' + msg));
    } else {
      statusEl.textContent = msg;
    }
  }

  // Tools: download & email evidence
  downloadBtn.addEventListener('click', async () => {
    downloadBtn.disabled = true;
    try {
      const rec = await buildAcceptanceRecordBase();
      try { rec.server_order_id = localStorage.getItem('last_order_id') || null; } catch (e) {}
      const blob = new Blob([JSON.stringify(rec, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `techbrot_evidence_${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
      a.click();
    } catch (e) {
      console.error('Download evidence failed', e);
      alert('Failed to create evidence file.');
    } finally {
      downloadBtn.disabled = false;
    }
  });

  emailBtn.addEventListener('click', async () => {
    emailBtn.disabled = true;
    try {
      const rec = await buildAcceptanceRecordBase();
      try { rec.server_order_id = localStorage.getItem('last_order_id') || null; } catch (e) {}
      const body = encodeURIComponent(JSON.stringify(rec, null, 2));
      location.href = `mailto:support@techbrot.com?subject=Evidence%20from%20checkout&body=${body}`;
    } catch (e) {
      console.error('Email evidence failed', e);
      alert('Failed to prepare email.');
    } finally {
      emailBtn.disabled = false;
    }
  });

  // Clear transient status after inactivity
  setTimeout(() => { if (!statusEl.textContent) statusEl.textContent = ''; }, 5000);

  // Email input: ensure proceed is only allowed when email valid + checkbox checked
  function updateProceedStateFromInputs() {
    const emailValid = emailInput && emailInput.value && emailInput.checkValidity();
    if (emailValid && realCheckbox.checked) {
      proceedBtn.disabled = false;
      downloadBtn.disabled = false;
      emailBtn.disabled = false;
    } else {
      proceedBtn.disabled = true;
      downloadBtn.disabled = true;
      emailBtn.disabled = true;
    }
  }
  emailInput.addEventListener('input', updateProceedStateFromInputs);

  // Ensure checkbox toggles still respect email validity
  fakeCheckbox.addEventListener('click', updateProceedStateFromInputs);

  console.info('TechBrot acceptance frontend loaded (full, with skeleton & animated checkbox).');

})();
</script>

</body>
</html>
